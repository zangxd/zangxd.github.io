<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>AngularJs核心原理简析二 · zangxd</title><meta name="description" content="AngularJs核心原理简析二 - zangxd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/nirvana.css"><link rel="search" type="application/opensearchdescription+xml" href="https://zangxd.com/atom.xml" title="zangxd"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/zangxd" target="_blank" class="nav-list-link">GitHub</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">AngularJs核心原理简析二</h1><div class="post-info">2016年9月2日</div><div class="post-content"><h2 id="核心原理解析"><a href="#核心原理解析" class="headerlink" title="核心原理解析"></a>核心原理解析</h2><h3 id="注入器的创建与使用，依赖注入原理：Provider和Injector"><a href="#注入器的创建与使用，依赖注入原理：Provider和Injector" class="headerlink" title="注入器的创建与使用，依赖注入原理：Provider和Injector"></a>注入器的创建与使用，依赖注入原理：Provider和Injector</h3><blockquote>
<p>Angular源码中注入器的创建方法createInjector，此方法，会创建两种不同的注入器：第一种叫做providerInjector，第二种叫做instanceInjector。providerInjector是用来创建provider的，instanceInjector是用来创建一个对象实例的。</p>
</blockquote>
<p>我们可以在js代码中直接使用注入器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var myModule = angular.module(&quot;myModule&quot;, []);</div><div class="line">myModule.factory(&quot;person&quot;, function()&#123;    //定义了一个服务person</div><div class="line">　　return &#123;</div><div class="line">　　　　name:&quot;zangxd&quot;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//myController依赖于服务person，但是它不声明依赖于person，而是通过注入器$injector来获得服务person的实例对象。</div><div class="line">myModule.controller(&quot;myController&quot;, [&quot;$scope&quot;, &quot;$injector&quot;,     </div><div class="line">　　function($scope, $injector)&#123;</div><div class="line">　　　　$injector.invoke(function(person)&#123;   //通过注入器$injector的invoke方法，把服务person的实例注入到函数function中。</div><div class="line">　　　　　　console.log(person.name);</div><div class="line">　　　　&#125;);</div><div class="line">　　&#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>注入器$injector的<code>annotate</code>方法的作用：<strong>它主要分析函数的参数签名</strong>。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$injector.annotate(function(arg1,arg2)&#123;&#125;)会得到[arg1, arg2]。</div></pre></td></tr></table></figure>
<p>在前面的操作中，我们经常使用函数参数声明的方式来注入一个服务（实例对象），其实angular就是通过annotate方法得到参数的名字，然后通过注入器实例化这些对象，最后注入到函数中。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function annotate(fn) &#123;</div><div class="line">    var $inject,</div><div class="line">        fnText,</div><div class="line">        argDecl,</div><div class="line">        last;</div><div class="line"></div><div class="line">    if (typeof fn == &apos;function&apos;) &#123;</div><div class="line">        if (!($inject = fn.$inject)) &#123;</div><div class="line">            $inject = [];</div><div class="line">            if (fn.length) &#123;</div><div class="line">                fnText = fn.toString().replace(STRIP_COMMENTS, &apos;&apos;);</div><div class="line">                argDecl = fnText.match(FN_ARGS);</div><div class="line">                forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg)&#123;</div><div class="line">                    arg.replace(FN_ARG, function(all, underscore, name)&#123;</div><div class="line">                        $inject.push(name);</div><div class="line">                    &#125;);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            fn.$inject = $inject;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (isArray(fn)) &#123;</div><div class="line">        last = fn.length - 1;</div><div class="line">        assertArgFn(fn[last], &apos;fn&apos;);</div><div class="line">        $inject = fn.slice(0, last);</div><div class="line">    &#125; else &#123;</div><div class="line">        assertArgFn(fn, &apos;fn&apos;, true);</div><div class="line">    &#125;</div><div class="line">    return $inject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>它是怎么获得函数的参数声明的呢？其实它是通过函数的toString方法得到整个函数的描述，然后通过正则表达式得到函数的参数。</p>
</blockquote>
<p>在angular中，所有的provider都可以用来进行注入。我们创建provider有以下几种方式：</p>
<p><code>provider</code>,<code>factory</code>,<code>service</code>,<code>constant</code>,<code>value</code>。</p>
<p>我们创建好provider之后，注入到哪里去呢？我们有以下几种方式来注入provider：</p>
<p><code>controller</code>,<code>directive</code>,<code>filter</code>,<code>service</code>,<code>factory</code>等。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var myModule = angular.module(&quot;myModule&quot;, []);</div><div class="line"></div><div class="line">myModule.provider(&quot;helloAngular&quot;, function()&#123;      //通过provider方法创建一个服务提供者helloAngular</div><div class="line"></div><div class="line">　　return &#123;</div><div class="line">　　　　$get : function()&#123;    //provider方法来定义服务提供者的话，必须定义$get方法。</div><div class="line">　　　　　　var name = &quot;zangxd&quot;;</div><div class="line">　　　　　　function getName()&#123;</div><div class="line">　　　　　　　　return name;</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　　　return &#123;</div><div class="line">　　　　　　　　getName: getName</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myModule.controller(&quot;myController&quot;, [&quot;$scope&quot;, &quot;helloAngular&quot; ,     //通过controller方法注入helloAngular服务，也就是注入一个helloAngular服务的实例对象</div><div class="line">　　function($scope, helloAngular)&#123;</div><div class="line">　　　　$scope.name = helloAngular.getName();     //使用helloAngular服务的实例对象</div><div class="line">　　&#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<p>第二个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var myModule = angular.module(&quot;myModule&quot;, []);</div><div class="line">myModule.factory(&quot;helloAngular&quot;, function()&#123;      //通过factory方法创建一个服务提供者helloAngular</div><div class="line">　　var name = &quot;zangxd&quot;;</div><div class="line">　　function getName()&#123;</div><div class="line">　　&#125;</div><div class="line">　　return &#123;</div><div class="line">　　　　getName:getName</div><div class="line">　　&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myModule.controller(&quot;myController&quot;, [&quot;$scope&quot;, &quot;helloAngular&quot; ,     //通过controller方法注入helloAngular服务，也就是注入一个helloAngular服务的实例对象</div><div class="line">　　function($scope, helloAngular)&#123;</div><div class="line">　　　　$scope.name = helloAngular.getName();     //使用helloAngular服务的实例对象</div><div class="line">　　&#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<p>第三个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var myModule = angular.module(&quot;myModule&quot;, []);</div><div class="line">myModule.service(&quot;helloAngular&quot;, function()&#123;      //通过service方法创建一个服务提供者helloAngular</div><div class="line">　　this.name = &quot;chaojidan&quot;;</div><div class="line">　　this.getName = function()&#123;</div><div class="line">　　　　return this.name;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myModule.controller(&quot;myController&quot;, [&quot;$scope&quot;, &quot;helloAngular&quot; ,     //通过controller方法注入helloAngular服务，也就是注入一个helloAngular服务的实例对象</div><div class="line"></div><div class="line">　　function($scope, helloAngular)&#123;</div><div class="line">　　　　$scope.name = helloAngular.getName();     //使用helloAngular服务的实例对象</div><div class="line">　　&#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<blockquote>
<p>其实从angular源码可以知道，创建provider的这几种方式：provider/factory/service/constant/value，其中，provider方法是基础，其他都是调用provider方法实现的，只是参数不同。从左到右，灵活性越差。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function provider(name, provider_) &#123;</div><div class="line">     assertNotHasOwnProperty(name, &apos;service&apos;);</div><div class="line">     if (isFunction(provider_) || isArray(provider_)) &#123;</div><div class="line">          provider_ = providerInjector.instantiate(provider_);</div><div class="line">     &#125;</div><div class="line">     if (!provider_.$get) &#123;</div><div class="line">         throw $injectorMinErr(&apos;pget&apos;, &quot;Provider &apos;&#123;0&#125;&apos; must define $get factory method.&quot;, name);</div><div class="line">     &#125;</div><div class="line">     return providerCache[name + providerSuffix] = provider_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function factory(name, factoryFn) &#123;</div><div class="line">　　　return provider(name, &#123; $get: factoryFn &#125;);</div><div class="line">&#125;</div><div class="line">function service(name, constructor) &#123;</div><div class="line">      return factory(name, [&apos;$injector&apos;, function($injector) &#123;</div><div class="line">          return $injector.instantiate(constructor);</div><div class="line">      &#125;]);</div><div class="line">&#125;</div><div class="line">function value(name, val) &#123;</div><div class="line">　　return factory(name, valueFn(val));</div><div class="line">&#125;</div><div class="line">function constant(name, value) &#123;</div><div class="line">    assertNotHasOwnProperty(name, &apos;constant&apos;);</div><div class="line">    providerCache[name] = value;</div><div class="line">    instanceCache[name] = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createInjector</code>方法里面，其实是通过<code>createInternalInjector</code>方法来创建注入器的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">function createInternalInjector(cache, factory) &#123;</div><div class="line">        function getService(serviceName) &#123;     //注入器可以用来获取一个服务的实例</div><div class="line">                if (cache.hasOwnProperty(serviceName)) &#123;</div><div class="line">                    if (cache[serviceName] === INSTANTIATING) &#123;</div><div class="line">                        throw $injectorMinErr(&apos;cdep&apos;, &apos;Circular dependency found: &#123;0&#125;&apos;, path.join(&apos; &lt;- &apos;));</div><div class="line">                    &#125;</div><div class="line">                    return cache[serviceName];</div><div class="line">                &#125; else &#123;</div><div class="line">                    try &#123;</div><div class="line">                        path.unshift(serviceName);</div><div class="line">                        cache[serviceName] = INSTANTIATING;</div><div class="line">                        return cache[serviceName] = factory(serviceName);</div><div class="line">                    &#125; catch (err) &#123;</div><div class="line">                        if (cache[serviceName] === INSTANTIATING) &#123;</div><div class="line">                            delete cache[serviceName];</div><div class="line">                        &#125;</div><div class="line">                        throw err;</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        path.shift();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        function invoke(fn, self, locals)&#123;    //可以用来调用一个方法</div><div class="line">                var args = [],</div><div class="line">                    $inject = annotate(fn),</div><div class="line">                    length, i,</div><div class="line">                    key;</div><div class="line"></div><div class="line">                for(i = 0, length = $inject.length; i &lt; length; i++) &#123;</div><div class="line">                    key = $inject[i];</div><div class="line">                    if (typeof key !== &apos;string&apos;) &#123;</div><div class="line">                        throw $injectorMinErr(&apos;itkn&apos;,</div><div class="line">                            &apos;Incorrect injection token! Expected service name as string, got &#123;0&#125;&apos;, key);</div><div class="line">                    &#125;</div><div class="line">                    args.push(</div><div class="line">                        locals &amp;&amp; locals.hasOwnProperty(key)</div><div class="line">                            ? locals[key]</div><div class="line">                            : getService(key)</div><div class="line">                    );</div><div class="line">                &#125;</div><div class="line">                if (!fn.$inject) &#123;</div><div class="line">                    // this means that we must be an array.</div><div class="line">                    fn = fn[length];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // http://jsperf.com/angularjs-invoke-apply-vs-switch</div><div class="line">                // #5388</div><div class="line">                return fn.apply(self, args);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     function instantiate(Type, locals) &#123;   //可以用来实例化一个对象</div><div class="line">                var Constructor = function() &#123;&#125;,</div><div class="line">                    instance, returnedValue;</div><div class="line"></div><div class="line">                // Check if Type is annotated and use just the given function at n-1 as parameter</div><div class="line">                // e.g. someModule.factory(&apos;greeter&apos;, [&apos;$window&apos;, function(renamed$window) &#123;&#125;]);</div><div class="line">                Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;</div><div class="line">                instance = new Constructor();</div><div class="line">                returnedValue = invoke(Type, instance, locals);</div><div class="line"></div><div class="line">                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;    //返回的对象，其实就是注入器</div><div class="line">                invoke: invoke,</div><div class="line">                instantiate: instantiate,</div><div class="line">                get: getService,</div><div class="line">                annotate: annotate,    //可以用来分析一个函数的签名</div><div class="line">                has: function(name) &#123;</div><div class="line">                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);</div><div class="line">                &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注入器总共有<code>invoke</code>，<code>instantiate</code>，<code>get</code>，<code>annotate</code>，<code>has</code>五个方法，其中，annotate用来分析一个函数的签名，也就是函数的参数，invoke用来调用一个函数，get用来获得一个服务的实例对象，instantiate用来实例化一个对象。</p>
<p>angularJS在初始化启动时，注册了一些内置的provider。在publishExternalAPI方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$provide.provider(&#123;</div><div class="line">    $anchorScroll: $AnchorScrollProvider,</div><div class="line">    $animate: $AnimateProvider,</div><div class="line">    $browser: $BrowserProvider,</div><div class="line">    $cacheFactory: $CacheFactoryProvider,</div><div class="line">    $controller: $ControllerProvider,</div><div class="line">    $document: $DocumentProvider,</div><div class="line">    $exceptionHandler: $ExceptionHandlerProvider,</div><div class="line">    $filter: $FilterProvider,</div><div class="line">    $interpolate: $InterpolateProvider,</div><div class="line">    $interval: $IntervalProvider,</div><div class="line">    $http: $HttpProvider,</div><div class="line">    $httpBackend: $HttpBackendProvider,</div><div class="line">    $location: $LocationProvider,</div><div class="line">    $log: $LogProvider,</div><div class="line">    $parse: $ParseProvider,</div><div class="line">    $rootScope: $RootScopeProvider,</div><div class="line">    $q: $QProvider,</div><div class="line">    $sce: $SceProvider,</div><div class="line">    $sceDelegate: $SceDelegateProvider,</div><div class="line">    $sniffer: $SnifferProvider,</div><div class="line">    $templateCache: $TemplateCacheProvider,</div><div class="line">    $timeout: $TimeoutProvider,</div><div class="line">    $window: $WindowProvider</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们以<code>$controller: $ControllerProvider</code>,为例子，来看下内置的provider是如何定义的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">function $ControllerProvider() &#123;</div><div class="line">    var controllers = &#123;&#125;,</div><div class="line">        CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;</div><div class="line">    this.register = function(name, constructor) &#123;    </div><div class="line">        assertNotHasOwnProperty(name, &apos;controller&apos;);</div><div class="line">        if (isObject(name)) &#123;</div><div class="line">            extend(controllers, name);</div><div class="line">        &#125; else &#123;</div><div class="line">            controllers[name] = constructor;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    this.$get = [&apos;$injector&apos;, &apos;$window&apos;, function($injector, $window) &#123;    //provider必须有$get方法</div><div class="line">        return function(expression, locals) &#123;</div><div class="line">            var instance, match, constructor, identifier;</div><div class="line">            if(isString(expression)) &#123;</div><div class="line">                match = expression.match(CNTRL_REG),</div><div class="line">                    constructor = match[1],</div><div class="line">                    identifier = match[3];</div><div class="line">                expression = controllers.hasOwnProperty(constructor)</div><div class="line">                    ? controllers[constructor]</div><div class="line">                    : getter(locals.$scope, constructor, true) || getter($window, constructor, true);</div><div class="line">                assertArgFn(expression, constructor, true);</div><div class="line">            &#125;</div><div class="line">            instance = $injector.instantiate(expression, locals);    //当你想去拿控制器，也就是controller实例时，实际上是注入器帮你实例化的。</div><div class="line">            if (identifier) &#123;</div><div class="line">                if (!(locals &amp;&amp; typeof locals.$scope == &apos;object&apos;)) &#123;</div><div class="line">                    throw minErr(&apos;$controller&apos;)(&apos;noscp&apos;,</div><div class="line">                        &quot;Cannot export controller &apos;&#123;0&#125;&apos; as &apos;&#123;1&#125;&apos;! No $scope object provided via `locals`.&quot;,</div><div class="line">                        constructor || expression.name, identifier);</div><div class="line">                &#125;</div><div class="line">                locals.$scope[identifier] = instance;</div><div class="line">            &#125;</div><div class="line">            return instance;</div><div class="line">        &#125;;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你的应用中，需要控制器实例对象时，也就是需要<code>controller</code>这个服务时，实际上是注入器在<code>ControllerProvider</code>（控制器服务提供者）中实例化一个控制器实例对象，然后给应用的（注入进去）。</p>
<h3 id="3-指令的执行过程"><a href="#3-指令的执行过程" class="headerlink" title="3.指令的执行过程"></a>3.指令的执行过程</h3><p>指令有两个执行阶段一个是<code>compile</code>，一个是<code>link</code>。我们可以在指令中自定义compile。</p>
<p>首先，我们来讲解如何自定义link函数</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html ng-app=&quot;myModule&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">　　　　&lt;hello&gt;&lt;/hello&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;helloAngular.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var myModule = angular.module(&quot;myModule&quot;, []);</div><div class="line">myModule.directive(&quot;hello&quot;, function()&#123;</div><div class="line">    return &#123;</div><div class="line">    　　restrict: &quot;E&quot;,</div><div class="line">　　　　 template: &quot;&lt;div&gt;Hello,Angular&lt;/div&gt;&quot;,</div><div class="line">　　　　 replace: true,</div><div class="line">        link: function(scope, el, attrs, controller)&#123;</div><div class="line">　　　　　　  el.on(&quot;click&quot;, function()&#123;</div><div class="line">　　　　　　　　　　alert(&quot;鼠标点击&quot;);</div><div class="line">　　　　　　　&#125;);</div><div class="line">　　　　 &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>link</code>方法一般用来对元素进行处理。这里是对元素进行事件的绑定。当用户元素div进行点击时，会弹出鼠标点击的框。</p>
</blockquote>
<p>然后，我们了解下如何自定义compile函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html ng-app=&quot;myModule&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">　　　　&lt;div hellos=&quot;3&quot;&gt;</div><div class="line">　　　　　　&lt;p&gt;hello,Angular!&lt;/p&gt;</div><div class="line">　　　　&lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;helloAngular.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var myModule = angular.module(&quot;myModule&quot;, []);</div><div class="line">myModule.directive(&quot;hellos&quot;, function()&#123;</div><div class="line">    return &#123;</div><div class="line">    　　restrict: &quot;A&quot;,</div><div class="line">        compile: function(el, attrs, transclude)&#123;</div><div class="line">　　　　　　   alert(&quot;指令编译&quot;);</div><div class="line">　　　　　　　　var tpl = el.children().clone();    //p标签以及内容</div><div class="line">　　　　　　　　for(var i =0;i&lt;attrs.hellos -1;i++)&#123;</div><div class="line">　　　　　　　　　　el.append(tpl.clone());</div><div class="line">　　　　　　　　&#125;</div><div class="line">　　　　　　　　return function(scope, el, attrs, controller)&#123;   //compile必须要return这样的一个函数，这个函数其实就是link函数，在链接阶段，就会执行此link函数。</div><div class="line">　　　　　　　　　　alert(&quot;指令链接&quot;);</div><div class="line">　　　　　　　　&#125;</div><div class="line"></div><div class="line">　　　　 &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当页面加载进来后，就会弹出指令编译，然后再弹出指令链接的框。</p>
<p>如果，我们在上面的helloAngular.js中，不仅自定义了compile方法，而且也自定义了link方法。比如：</p>
<figure class="highlight plain"><figcaption><span>myModule = angular.module("myModule", []);</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">myModule.directive(&quot;hellos&quot;, function()&#123;    //定义一个hellos指令</div><div class="line">    return &#123;</div><div class="line">    　　restrict: &quot;A&quot;,</div><div class="line">        compile: function(el, attrs, transclude)&#123;</div><div class="line">　　　　　　   alert(&quot;指令编译&quot;);</div><div class="line">　　　　　　　　var tpl = el.children().clone();    //p标签以及内容</div><div class="line">　　　　　　　　for(var i =0;i&lt;attrs.hellos -1;i++)&#123;</div><div class="line">　　　　　　　　　　el.append(tpl.clone());</div><div class="line">　　　　　　　　&#125;</div><div class="line">　　　　　　　　return function(scope, el, attrs, controller)&#123;  //compile必须要return这样的一个函数，这个函数其实就是link函数，在链接阶段，就会执行此link函数。</div><div class="line">　　　　　　　　　　alert(&quot;指令链接&quot;);</div><div class="line">　　　　　　　　&#125;</div><div class="line"></div><div class="line">　　　　 &#125;</div><div class="line">　　　　 link : function(scope, el, attrs, controller)&#123;</div><div class="line">　　　　　　　　alert(&quot;自定义的link&quot;);</div><div class="line">　　　　 &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当页面加载进来时，自定义的link不会弹出来。意思就是说，当存在compile时，不会执行你自定义的link函数，因为angular会把compile返回的函数当做link函数来执行。当不存在compile时，就会执行你自定义的link函数。</p>
<p><code>compile</code>和<code>link</code>函数的区别：</p>
<ul>
<li><p>compile函数很少被用到，写起来比较麻烦。</p>
</li>
<li><p>compile函数的作用是对指令的模板进行转换，比如，上面的例子中，compile函数就把指令的模板进行了叠加，改变了页面上的DOM结构。</p>
</li>
<li><p>link函数的作用是在模型和视图之间建立关联，同时在元素上绑定事件监听。</p>
</li>
<li><p>scope在链接阶段才会被绑定到元素上，因此在compile中操作scope会报错。</p>
</li>
<li><p>对于同一个指令的多个实例，compile只会执行一次，而link对于指令的每个实例都会执行一次。比如：ng-repeat指令，如果元素的ng-repeat=3，那么ng-repeat指令的compile只会执行一次，而link会执行三次。</p>
</li>
<li><p>对于指令，我们一般只需要自定义link函数就行了。</p>
</li>
</ul>
<p>接下来，我们来讲解 <strong>使用compile服务，在页面上查找指令并编译指令的过程</strong>：</p>
<ol>
<li><p>从ng-app开始，递归子层的DOM结构，收集指令，然后在ng-app指令的位置创建$rootScope作用域。比如：上面的代码中，我们注册了一个hellos指令，angular在启动时，就会遍历DOM去查找这个指令。</p>
</li>
<li><p>如果有需要，会为指令生成childScope。</p>
</li>
<li><p>调用每个指令自己的compile函数，生成自己的compositeLinkFn函数。</p>
</li>
<li><p>编译的结果是返回一个publicLinkFn函数。</p>
</li>
<li><p>编译完成之后立即调用生成的publicLinkFn函数。</p>
</li>
</ol>
<blockquote>
<p>angular对tree型的数据结构进行双向绑定时，不太理想，性能消耗太大。</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2016/09/07/用Angular开发移动App/" class="prev">PREV</a><a href="/2016/09/02/AngularJs核心原理简析一/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="https://zangxd.com">zangxd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-nirvana</a>.</p></div></footer></div><script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>