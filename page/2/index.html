<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>zangxd</title><meta name="description" content="zangxd | 前端 | 全栈 | zangxd's blog | css | javascript"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/nirvana.css"><link rel="search" type="application/opensearchdescription+xml" href="https://zangxd.com/atom.xml" title="zangxd"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/zangxd" target="_blank" class="nav-list-link">GitHub</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/30/CSS之将footer固定在页面底部/" class="post-title-link">CSS之将footer固定在页面底部</a></h2><div class="post-info">2016年8月29日</div><div class="post-content"><h2 id="方法一：footer高度固定-绝对定位"><a href="#方法一：footer高度固定-绝对定位" class="headerlink" title="方法一：footer高度固定+绝对定位"></a>方法一：footer高度固定+绝对定位</h2><p>HTML结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;header&gt;header&lt;/header&gt;</div><div class="line">    &lt;main&gt;main content&lt;/main&gt;</div><div class="line">    &lt;footer&gt;footer&lt;/footer&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>CSS设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">html&#123;height:100%;&#125;</div><div class="line">body&#123;min-height:100%;margin:0;padding:0;position:relative;&#125;</div><div class="line">header&#123;background-color: #ffe4c4;&#125;</div><div class="line">main&#123;padding-bottom:100px;background-color: #bdb76b;&#125;/* main的padding-bottom值要等于或大于footer的height值 */</div><div class="line">footer&#123;position:absolute;bottom:0;width:100%;height:100px;background-color: #ffc0cb;&#125;</div></pre></td></tr></table></figure></p></div><a href="/2016/08/30/CSS之将footer固定在页面底部/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/30/CSS之如何布局让两列等高/" class="post-title-link">CSS之如何布局让两列等高</a></h2><div class="post-info">2016年8月29日</div><div class="post-content"></div><a href="/2016/08/30/CSS之如何布局让两列等高/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/28/EcmaScript-6学习笔记三/" class="post-title-link">EcmaScript 6学习笔记三</a></h2><div class="post-info">2016年8月28日</div><div class="post-content"><blockquote>
<p>基于EcmaScript 6学习中的简要代码记录</p>
</blockquote>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// let 变量</div><div class="line">var a = 1;</div><div class="line">if(a === 1)&#123;</div><div class="line">  var b = 2;</div><div class="line">&#125;</div><div class="line">console.log(b); //2</div><div class="line"></div><div class="line">if(a === 1)&#123;</div><div class="line">  let b = 2;</div><div class="line">&#125;</div><div class="line">console.log(b);// b is not undefined</div><div class="line"></div><div class="line">// const 常量</div><div class="line">const _name = &apos;xd&apos;;</div><div class="line">// let name=&apos;&apos;;//Identifier &apos;name&apos; has already been declared</div><div class="line">// _name=&apos;zangxd&apos;;//Assignment to constant variable.</div></pre></td></tr></table></figure></div><a href="/2016/08/28/EcmaScript-6学习笔记三/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/28/EcmaScript-6学习笔记二/" class="post-title-link">EcmaScript 6学习笔记二</a></h2><div class="post-info">2016年8月28日</div><div class="post-content"><h2 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h2><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><strong>Set结构有以下属性：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Set.prototype.constructor</div><div class="line">// 构造函数，默认就是Set函数。</div><div class="line"></div><div class="line">Set.prototype.size</div><div class="line">//返回Set的成员总数</div></pre></td></tr></table></figure>
<p><strong>Set数据结构有以下方法：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">add(value)：添加某个值，返回Set结构本身。</div><div class="line"></div><div class="line">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</div><div class="line"></div><div class="line">has(value)：返回一个布尔值，表示该值是否为Set的成员。</div><div class="line"></div><div class="line">clear()：清除所有成员，没有返回值。</div></pre></td></tr></table></figure></div><a href="/2016/08/28/EcmaScript-6学习笔记二/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/27/EcmaScript-6学习笔记一/" class="post-title-link">EcmaScript 6学习笔记一</a></h2><div class="post-info">2016年8月27日</div><div class="post-content"><h2 id="作用域不同"><a href="#作用域不同" class="headerlink" title="作用域不同"></a>作用域不同</h2><p>ES6中，let和const实际上为JavaScript新增了<code>块级作用域</code>，函数本身的作用域，在其所在的块级作用域之内。</p>
<ol>
<li><p>let和const的用法</p>
<p> <strong>相同点：</strong></p>
<ul>
<li><p>用来声明变量。</p>
</li>
<li><p>声明的变量只在它所在的代码块有效。</p>
</li>
<li><p>不像var那样，会发生“变量提升”现象，只要块级作用域内存在let或const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
</li>
<li><p>不允许在相同作用域内，重复声明同一个变量。</p>
<p><strong>不同点：</strong></p>
</li>
<li>const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。let声明的变量可以改变。</li>
</ul>
</li>
<li><p>全局对象</p>
<ul>
<li>ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性，无法通过window/global获取。</li>
</ul>
</li>
</ol></div><a href="/2016/08/27/EcmaScript-6学习笔记一/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/25/浏览器简析之了解浏览器/" class="post-title-link">浏览器简析之了解浏览器</a></h2><div class="post-info">2016年8月24日</div><div class="post-content"><h3 id="浏览器的主要构成部分"><a href="#浏览器的主要构成部分" class="headerlink" title="浏览器的主要构成部分"></a>浏览器的主要构成部分</h3><p>浏览器主要分为用户界面，浏览器引擎，渲染引擎，数据存储几个大部分。其中渲染引擎又包含网络、JS解释器<br>、UI后端几部分。如下图所示：<br><img src="/img/brower.png" alt="img"></p>
<h3 id="浏览器各部分功能简介"><a href="#浏览器各部分功能简介" class="headerlink" title="浏览器各部分功能简介"></a>浏览器各部分功能简介</h3><h4 id="1-User-Interface-用户界面"><a href="#1-User-Interface-用户界面" class="headerlink" title="1.User Interface 用户界面"></a>1.User Interface 用户界面</h4><p>通俗的说就是浏览器呈现给用户的样子，如顶部（前进，后退，刷新，停止，地址栏，书签栏，状态栏，工具栏等按钮），侧栏（滚动条），底栏（滚动条），自带的开发工具，下拉菜单，下载管理等，当然每个浏览器厂商还有自己的特性。<br></div><a href="/2016/08/25/浏览器简析之了解浏览器/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/24/浏览器简析之渲染机制/" class="post-title-link">浏览器简析之渲染机制</a></h2><div class="post-info">2016年8月23日</div><div class="post-content"><blockquote>
<p>本文参考学习<a href="http://delai.me/" target="_blank" rel="external">德来大师</a>的<a href="https://segmentfault.com/a/1190000004292479,且本文提到的浏览器均是指Chrome。" target="_blank" rel="external">https://segmentfault.com/a/1190000004292479,且本文提到的浏览器均是指Chrome。</a></p>
</blockquote>
<p><strong>几个概念</strong></p>
<p>1、<code>DOM</code>：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。</p>
<p>2、<code>CSSOM</code>：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。</p>
<p>3、<code>DOM</code> 和 <code>CSSOM</code>都是以 Bytes → characters → tokens → nodes → object model. 这样的方式生成最终的数据。如下图所示：<br></div><a href="/2016/08/24/浏览器简析之渲染机制/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/21/Bower-笔记/" class="post-title-link">Bower 笔记</a></h2><div class="post-info">2016年8月20日</div><div class="post-content"><h4 id="Bower（依赖管理工具，为了更好的管理好各js之间的依赖关系）-介绍"><a href="#Bower（依赖管理工具，为了更好的管理好各js之间的依赖关系）-介绍" class="headerlink" title="Bower（依赖管理工具，为了更好的管理好各js之间的依赖关系） 介绍"></a>Bower（依赖管理工具，为了更好的管理好各js之间的依赖关系） 介绍</h4><p>Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。（最通俗的实例场景是：比如项目中用到的jquery是1.X的版本，但引入Bootstrap时需要1.11.X的版本，则可通过bower自动解决。）</p>
<h4 id="Bower安装"><a href="#Bower安装" class="headerlink" title="Bower安装"></a>Bower安装</h4><p>打开终端，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g bower</div></pre></td></tr></table></figure></p>
<p>其中-g命令表示全局安装</p>
<h4 id="开始使用Bower"><a href="#开始使用Bower" class="headerlink" title="开始使用Bower"></a>开始使用Bower</h4><p>可通过<code>bower help</code>命令查看<code>bower</code>可以完成那些操作，如下：<br></div><a href="/2016/08/21/Bower-笔记/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/21/简单的组织JS代码/" class="post-title-link">简单的组织JS代码</a></h2><div class="post-info">2016年8月20日</div><div class="post-content"></div><a href="/2016/08/21/简单的组织JS代码/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/12/关于前端工程化/" class="post-title-link">关于前端工程化</a></h2><div class="post-info">2016年8月11日</div><div class="post-content"><h4 id="什么是前后端分离"><a href="#什么是前后端分离" class="headerlink" title="什么是前后端分离"></a>什么是前后端分离</h4><p>传统的开发是前端的代码部署在后端的代码里，然后耦合起来进行协同开发和发布，往往前端部分的修改都需要后端开发和测试人员的参与，开发效率没有达到最优化。前后端分离，由此而出。后端只处理接口数据，中端（NodeJS）处理接口、渲染数据，前端页面开发。前后端完全分离，并且便于单元测试、集成测试，中端在前后端分离中担任着中间人的角色，用它来处理路由、模板等事情。前端与后端再无直接关系，并且是两个不同的工程。</p>
<h4 id="项目前端JS构建需注意哪些？"><a href="#项目前端JS构建需注意哪些？" class="headerlink" title="项目前端JS构建需注意哪些？"></a>项目前端JS构建需注意哪些？</h4><ol>
<li>代码逻辑分层</li>
<li>便于多人协作开发</li>
<li>各部分代码模块化，可以按需加载</li>
<li>保持全局变量的清洁</li>
<li>可进行单元测试</li>
</ol>
<h4 id="构建工具及其基础库"><a href="#构建工具及其基础库" class="headerlink" title="构建工具及其基础库"></a>构建工具及其基础库</h4><ol>
<li>构建工具<br>webpack：前端静态资源打包工具（会自动分析依赖，然后编译打包，可配置代码分割，提供按需加载的能力），可以把项目的各种js文、css文件等打包合并成一个或多个文件。<br>gulp: 自动化构建工具，用于优化前端工作流程，用于配置自动刷新页面，js，css压缩，编译less文件等。<br>bower：项目依赖的包管理器。</li>
<li>基础库<br>angularJs OR other</div><a href="/2016/08/12/关于前端工程化/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">PREV</a><a href="/page/3/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="https://zangxd.com">zangxd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-nirvana</a>.</p></div></footer></div><script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>